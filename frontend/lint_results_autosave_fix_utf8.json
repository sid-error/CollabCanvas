
> frontend@0.0.0 lint
> eslint . --quiet --format json

[{"filePath":"C:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\components\\ui\\SaveIndicator.tsx","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Date.now` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\components\\ui\\SaveIndicator.tsx:37:41\n  35 |         if (unsavedChanges > 0) return `${unsavedChanges} unsaved change${unsavedChanges !== 1 ? 's' : ''}`;\n  36 |         if (lastSaveTime) {\n> 37 |             const timeAgo = Math.floor((Date.now() - lastSaveTime.getTime()) / 1000);\n     |                                         ^^^^^^^^^^ Cannot call impure function\n  38 |             if (timeAgo < 60) return `Saved ${timeAgo} second${timeAgo !== 1 ? 's' : ''} ago`;\n  39 |             if (timeAgo < 3600) return `Saved ${Math.floor(timeAgo / 60)} minute${Math.floor(timeAgo / 60) !== 1 ? 's' : ''} ago`;\n  40 |             return `Saved at ${lastSaveTime.toLocaleTimeString()}`;","line":37,"column":41,"nodeType":null,"endLine":37,"endColumn":51}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { Save, Check, AlertCircle, Clock, Loader } from 'lucide-react';\r\n\r\ninterface SaveIndicatorProps {\r\n    lastSaveTime: Date | null;\r\n    unsavedChanges: number;\r\n    isSaving: boolean;\r\n    error: Error | null;\r\n    onManualSave?: () => void;\r\n    onToggleAutoSave?: (enabled: boolean) => void;\r\n    isAutoSaveEnabled?: boolean;\r\n    className?: string;\r\n}\r\n\r\nexport const SaveIndicator: React.FC<SaveIndicatorProps> = ({\r\n    lastSaveTime,\r\n    unsavedChanges,\r\n    isSaving,\r\n    error,\r\n    onManualSave,\r\n    onToggleAutoSave,\r\n    isAutoSaveEnabled = true,\r\n    className = ''\r\n}) => {\r\n    const getStatusIcon = () => {\r\n        if (isSaving) return <Loader size={14} className=\"text-blue-500 animate-spin\" />;\r\n        if (error) return <AlertCircle size={14} className=\"text-red-500\" />;\r\n        if (unsavedChanges > 0) return <Clock size={14} className=\"text-yellow-500\" />;\r\n        return <Check size={14} className=\"text-green-500\" />;\r\n    };\r\n\r\n    const getStatusText = () => {\r\n        if (isSaving) return 'Saving...';\r\n        if (error) return `Save failed: ${error.message}`;\r\n        if (unsavedChanges > 0) return `${unsavedChanges} unsaved change${unsavedChanges !== 1 ? 's' : ''}`;\r\n        if (lastSaveTime) {\r\n            const timeAgo = Math.floor((Date.now() - lastSaveTime.getTime()) / 1000);\r\n            if (timeAgo < 60) return `Saved ${timeAgo} second${timeAgo !== 1 ? 's' : ''} ago`;\r\n            if (timeAgo < 3600) return `Saved ${Math.floor(timeAgo / 60)} minute${Math.floor(timeAgo / 60) !== 1 ? 's' : ''} ago`;\r\n            return `Saved at ${lastSaveTime.toLocaleTimeString()}`;\r\n        }\r\n        return 'Not saved yet';\r\n    };\r\n\r\n    return (\r\n        <div className={`flex items-center gap-2 px-3 py-1.5 bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm rounded-lg shadow-sm border border-slate-200 dark:border-slate-700 text-sm ${className}`}>\r\n            {/* Status Icon */}\r\n            <div className=\"flex items-center gap-1.5\">\r\n                {getStatusIcon()}\r\n                <span className={`text-xs ${error ? 'text-red-600 dark:text-red-400' :\r\n                    unsavedChanges > 0 ? 'text-yellow-600 dark:text-yellow-400' :\r\n                        'text-slate-600 dark:text-slate-400'\r\n                    }`}>\r\n                    {getStatusText()}\r\n                </span>\r\n            </div>\r\n\r\n            {/* Auto-save Toggle */}\r\n            {onToggleAutoSave && (\r\n                <button\r\n                    onClick={() => onToggleAutoSave(!isAutoSaveEnabled)}\r\n                    className={`px-2 py-0.5 text-xs rounded transition-colors ${isAutoSaveEnabled\r\n                        ? 'bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400'\r\n                        : 'bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-400'\r\n                        }`}\r\n                    title={isAutoSaveEnabled ? 'Disable auto-save' : 'Enable auto-save'}\r\n                >\r\n                    Auto\r\n                </button>\r\n            )}\r\n\r\n            {/* Manual Save Button */}\r\n            {onManualSave && unsavedChanges > 0 && (\r\n                <button\r\n                    onClick={onManualSave}\r\n                    disabled={isSaving}\r\n                    className=\"p-1 hover:bg-slate-100 dark:hover:bg-slate-700 rounded transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\r\n                    title=\"Save now\"\r\n                >\r\n                    <Save size={14} className=\"text-slate-600 dark:text-slate-400\" />\r\n                </button>\r\n            )}\r\n        </div>\r\n    );\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useLayers.ts","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useLayers.ts:67:7\n  65 |   useEffect(() => {\n  66 |     if (layerState.layers.length === 0) {\n> 67 |       createLayer('Background', true);\n     |       ^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  68 |     }\n  69 |   }, [createLayer, layerState.layers.length]);\n  70 |","line":67,"column":7,"nodeType":null,"endLine":67,"endColumn":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect } from 'react';\r\nimport type { Layer, LayerPanelState, DrawingElement } from '../types/canvas';\r\n\r\n/**\r\n * Default layer colors for visual distinction\r\n */\r\nconst LAYER_COLORS = [\r\n  '#3b82f6', // blue\r\n  '#ef4444', // red\r\n  '#10b981', // green\r\n  '#f59e0b', // amber\r\n  '#8b5cf6', // purple\r\n  '#ec4899', // pink\r\n  '#06b6d4', // cyan\r\n  '#84cc16', // lime\r\n  '#f97316', // orange\r\n  '#6366f1', // indigo\r\n];\r\n\r\n/**\r\n * Custom hook for managing layers\r\n * \r\n * @param elements - Array of drawing elements\r\n * @param setElements - Function to update elements\r\n */\r\nexport function useLayers(\r\n  elements: DrawingElement[],\r\n  setElements: (elements: DrawingElement[] | ((prev: DrawingElement[]) => DrawingElement[])) => void\r\n) {\r\n  const [layerState, setLayerState] = useState<LayerPanelState>({\r\n    layers: [],\r\n    activeLayerId: null,\r\n    isExpanded: true,\r\n    panelWidth: 280\r\n  });\r\n\r\n  /**\r\n   * Create a new layer\r\n   */\r\n  const createLayer = useCallback((name?: string, setActive: boolean = true) => {\r\n    const newLayer: Layer = {\r\n      id: `layer-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,\r\n      name: name || `Layer ${layerState.layers.length + 1}`,\r\n      visible: true,\r\n      locked: false,\r\n      opacity: 1,\r\n      blendMode: 'normal',\r\n      index: layerState.layers.length,\r\n      elementIds: [],\r\n      color: LAYER_COLORS[layerState.layers.length % LAYER_COLORS.length]\r\n    };\r\n\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: [...prev.layers, newLayer],\r\n      activeLayerId: setActive ? newLayer.id : prev.activeLayerId\r\n    }));\r\n\r\n    return newLayer;\r\n  }, [layerState.layers]);\r\n\r\n  /**\r\n   * Initialize default layer if none exist\r\n   */\r\n  useEffect(() => {\r\n    if (layerState.layers.length === 0) {\r\n      createLayer('Background', true);\r\n    }\r\n  }, [createLayer, layerState.layers.length]);\r\n\r\n  /**\r\n   * Ensure all elements have valid layerIds\r\n   */\r\n  useEffect(() => {\r\n    if (layerState.layers.length === 0 || !layerState.activeLayerId) return;\r\n\r\n    // Check if any elements are missing layerId or have invalid layerId\r\n    const needsUpdate = elements.some(el =>\r\n      !el.layerId || !layerState.layers.find(l => l.id === el.layerId)\r\n    );\r\n\r\n    if (needsUpdate) {\r\n      setElements(prev => prev.map(el => ({\r\n        ...el,\r\n        layerId: el.layerId && layerState.layers.find(l => l.id === el.layerId)\r\n          ? el.layerId\r\n          : layerState.activeLayerId!\r\n      })));\r\n    }\r\n  }, [elements, layerState.layers, layerState.activeLayerId, setElements]);\r\n\r\n  /**\r\n   * Update layer element counts\r\n   */\r\n  const updateLayerElementCounts = useCallback(() => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer => ({\r\n        ...layer,\r\n        elementIds: elements\r\n          .filter(el => el.layerId === layer.id)\r\n          .map(el => el.id)\r\n      }))\r\n    }));\r\n  }, [elements]);\r\n\r\n  /**\r\n   * Delete a layer\r\n   */\r\n  const deleteLayer = useCallback((layerId: string) => {\r\n    // Don't delete if it's the last layer\r\n    if (layerState.layers.length <= 1) return;\r\n\r\n    setLayerState(prev => {\r\n      const newLayers = prev.layers.filter(l => l.id !== layerId);\r\n\r\n      // Move elements from deleted layer to next available layer\r\n      const targetLayerId = newLayers[0]?.id;\r\n\r\n      if (targetLayerId) {\r\n        setElements(prevElements =>\r\n          prevElements.map(el =>\r\n            el.layerId === layerId ? { ...el, layerId: targetLayerId } : el\r\n          )\r\n        );\r\n      }\r\n\r\n      // Update indices\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers,\r\n        activeLayerId: prev.activeLayerId === layerId ? newLayers[0]?.id : prev.activeLayerId\r\n      };\r\n    });\r\n  }, [layerState.layers, setElements]);\r\n\r\n  /**\r\n   * Duplicate a layer\r\n   */\r\n  const duplicateLayer = useCallback((layerId: string) => {\r\n    const sourceLayer = layerState.layers.find(l => l.id === layerId);\r\n    if (!sourceLayer) return;\r\n\r\n    // Create new layer\r\n    const newLayer: Layer = {\r\n      ...sourceLayer,\r\n      id: `layer-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,\r\n      name: `${sourceLayer.name} (copy)`,\r\n      index: sourceLayer.index + 1,\r\n      elementIds: []\r\n    };\r\n\r\n    // Duplicate elements from source layer\r\n    const elementsToDuplicate = elements.filter(el => el.layerId === layerId);\r\n    const newElements = elementsToDuplicate.map(el => ({\r\n      ...el,\r\n      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n      layerId: newLayer.id,\r\n      x: (el.x || 0) + 20, // Offset by 20px\r\n      y: (el.y || 0) + 20\r\n    }));\r\n\r\n    // Add new elements\r\n    setElements(prev => [...prev, ...newElements]);\r\n\r\n    // Update layers\r\n    setLayerState(prev => {\r\n      const newLayers = [...prev.layers];\r\n      newLayers.splice(sourceLayer.index + 1, 0, newLayer);\r\n\r\n      // Update indices of subsequent layers\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers,\r\n        activeLayerId: newLayer.id\r\n      };\r\n    });\r\n  }, [layerState.layers, elements, setElements]);\r\n\r\n  /**\r\n   * Toggle layer visibility\r\n   */\r\n  const toggleLayerVisibility = useCallback((layerId: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, visible: !layer.visible }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Toggle layer lock\r\n   */\r\n  const toggleLayerLock = useCallback((layerId: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, locked: !layer.locked }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Set active layer\r\n   */\r\n  const setActiveLayer = useCallback((layerId: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      activeLayerId: layerId\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Rename layer\r\n   */\r\n  const renameLayer = useCallback((layerId: string, newName: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, name: newName }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Change layer opacity\r\n   */\r\n  const setLayerOpacity = useCallback((layerId: string, opacity: number) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, opacity }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Change layer blend mode\r\n   */\r\n  const setLayerBlendMode = useCallback((layerId: string, blendMode: Layer['blendMode']) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, blendMode }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Reorder layers (drag and drop)\r\n   */\r\n  const reorderLayers = useCallback((sourceIndex: number, targetIndex: number) => {\r\n    if (sourceIndex === targetIndex) return;\r\n\r\n    setLayerState(prev => {\r\n      const newLayers = [...prev.layers];\r\n      const [movedLayer] = newLayers.splice(sourceIndex, 1);\r\n      newLayers.splice(targetIndex, 0, movedLayer);\r\n\r\n      // Update indices\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers\r\n      };\r\n    });\r\n  }, []);\r\n\r\n  /**\r\n   * Merge layer down\r\n   */\r\n  const mergeLayerDown = useCallback((layerId: string) => {\r\n    const layerIndex = layerState.layers.findIndex(l => l.id === layerId);\r\n    if (layerIndex <= 0) return; // Can't merge the bottom layer\r\n\r\n    const targetLayer = layerState.layers[layerIndex];\r\n    const bottomLayer = layerState.layers[layerIndex - 1];\r\n\r\n    // Move all elements from target layer to bottom layer\r\n    setElements(prev =>\r\n      prev.map(el =>\r\n        el.layerId === targetLayer.id\r\n          ? { ...el, layerId: bottomLayer.id }\r\n          : el\r\n      )\r\n    );\r\n\r\n    // Remove target layer\r\n    setLayerState(prev => {\r\n      const newLayers = prev.layers.filter((_, idx) => idx !== layerIndex);\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers,\r\n        activeLayerId: bottomLayer.id\r\n      };\r\n    });\r\n  }, [layerState.layers, setElements]);\r\n\r\n  /**\r\n   * Get elements for a specific layer (considering visibility)\r\n   */\r\n  const getLayerElements = useCallback((layerId: string): DrawingElement[] => {\r\n    const layer = layerState.layers.find(l => l.id === layerId);\r\n    if (!layer || !layer.visible) return [];\r\n\r\n    return elements.filter(el => el.layerId === layerId);\r\n  }, [elements, layerState.layers]);\r\n\r\n  /**\r\n   * Check if a layer is editable (visible and not locked)\r\n   */\r\n  const isLayerEditable = useCallback((layerId: string): boolean => {\r\n    const layer = layerState.layers.find(l => l.id === layerId);\r\n    return layer ? layer.visible && !layer.locked : false;\r\n  }, [layerState.layers]);\r\n\r\n  return {\r\n    layerState,\r\n    createLayer,\r\n    deleteLayer,\r\n    duplicateLayer,\r\n    toggleLayerVisibility,\r\n    toggleLayerLock,\r\n    setActiveLayer,\r\n    renameLayer,\r\n    setLayerOpacity,\r\n    setLayerBlendMode,\r\n    reorderLayers,\r\n    mergeLayerDown,\r\n    getLayerElements,\r\n    isLayerEditable,\r\n    updateLayerElementCounts,\r\n    setLayerState\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useObjectLocks.ts","messages":[{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `releaseLock`, but the source dependencies were [lockTimeout, myLocks]. Inferred different dependency than source.\n\nC:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useObjectLocks.ts:95:40\n   93 |      * Set timeout to auto-release a lock\n   94 |      */\n>  95 |     const setLockTimeout = useCallback((elementId: string) => {\n      |                                        ^^^^^^^^^^^^^^^^^^^^^^^^\n>  96 |         clearLockTimeout(elementId);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  97 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  98 |         lockTimeoutsRef.current[elementId] = setTimeout(() => {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  99 |             // Auto-release the lock after timeout\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 100 |             if (myLocks.has(elementId)) {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 101 |                 releaseLock(elementId, true); // true = auto-release\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 102 |             }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 103 |         }, lockTimeout);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 104 |     }, [lockTimeout, myLocks]);\n      | ^^^^^^ Could not preserve existing manual memoization\n  105 |\n  106 |     /**\n  107 |      * Request a lock on an object","line":95,"column":40,"nodeType":null,"endLine":104,"endColumn":6}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect, useRef } from 'react';\r\nimport type { Socket } from 'socket.io-client';\r\n\r\n/**\r\n * Interface for lock information\r\n */\r\nexport interface LockInfo {\r\n    userId: string;\r\n    username: string;\r\n    color: string;\r\n    timestamp: number;\r\n    elementId: string;\r\n}\r\n\r\n/**\r\n * Props for useObjectLocks hook\r\n */\r\ninterface UseObjectLocksProps {\r\n    socket: Socket | null;\r\n    roomId: string | undefined;\r\n    userId: string | undefined;\r\n    username: string | undefined;\r\n    userColor?: string;\r\n    lockTimeout?: number; // milliseconds before auto-release\r\n    isConnected?: boolean; // Add this for offline support\r\n    queueAction?: (type: string, data: any) => string; // Add this for offline queue\r\n}\r\n\r\n/**\r\n * Custom hook for managing object locking in collaborative environments\r\n * \r\n * @param props - Hook properties\r\n * @returns Lock state and functions\r\n */\r\nexport function useObjectLocks({\r\n    socket,\r\n    roomId,\r\n    userId,\r\n    username,\r\n    userColor = '#3b82f6',\r\n    lockTimeout = 30000, // 30 seconds default\r\n    isConnected = true,\r\n    queueAction\r\n}: UseObjectLocksProps) {\r\n    const [lockedObjects, setLockedObjects] = useState<Record<string, LockInfo>>({});\r\n    const [myLocks, setMyLocks] = useState<Set<string>>(new Set());\r\n\r\n    // Refs for timeout management\r\n    const lockTimeoutsRef = useRef<Record<string, NodeJS.Timeout>>({});\r\n\r\n    /**\r\n     * Clear timeout for a specific lock\r\n     */\r\n    const clearLockTimeout = useCallback((elementId: string) => {\r\n        if (lockTimeoutsRef.current[elementId]) {\r\n            clearTimeout(lockTimeoutsRef.current[elementId]);\r\n            delete lockTimeoutsRef.current[elementId];\r\n        }\r\n    }, []);\r\n\r\n    /**\r\n     * Release a lock on an object\r\n     */\r\n    const releaseLock = useCallback((elementId: string, isAutoRelease: boolean = false) => {\r\n        if (!roomId || !userId) return;\r\n\r\n        if (myLocks.has(elementId)) {\r\n            const releaseData = {\r\n                roomId,\r\n                elementId,\r\n                userId,\r\n                isAutoRelease\r\n            };\r\n\r\n            if (socket && isConnected) {\r\n                socket.emit('release-lock', releaseData);\r\n            } else if (queueAction) {\r\n                queueAction('release-lock', releaseData);\r\n            }\r\n\r\n            // Optimistically update local state\r\n            setMyLocks(prev => {\r\n                const next = new Set(prev);\r\n                next.delete(elementId);\r\n                return next;\r\n            });\r\n\r\n            clearLockTimeout(elementId);\r\n        }\r\n    }, [socket, roomId, userId, myLocks, clearLockTimeout, isConnected, queueAction]);\r\n\r\n    /**\r\n     * Set timeout to auto-release a lock\r\n     */\r\n    const setLockTimeout = useCallback((elementId: string) => {\r\n        clearLockTimeout(elementId);\r\n\r\n        lockTimeoutsRef.current[elementId] = setTimeout(() => {\r\n            // Auto-release the lock after timeout\r\n            if (myLocks.has(elementId)) {\r\n                releaseLock(elementId, true); // true = auto-release\r\n            }\r\n        }, lockTimeout);\r\n    }, [lockTimeout, myLocks]);\r\n\r\n    /**\r\n     * Request a lock on an object\r\n     */\r\n    const requestLock = useCallback((elementId: string) => {\r\n        if (!roomId || !userId) return false;\r\n\r\n        // Don't request if already locked by self\r\n        if (myLocks.has(elementId)) {\r\n            // Renew the timeout\r\n            setLockTimeout(elementId);\r\n            return true;\r\n        }\r\n\r\n        const lockData = {\r\n            roomId,\r\n            elementId,\r\n            userId,\r\n            username,\r\n            color: userColor\r\n        };\r\n\r\n        if (socket && isConnected) {\r\n            socket.emit('request-lock', lockData);\r\n        } else if (queueAction) {\r\n            // Queue for when we're back online\r\n            queueAction('request-lock', lockData);\r\n        }\r\n\r\n        return true;\r\n    }, [socket, roomId, userId, username, userColor, myLocks, setLockTimeout, isConnected, queueAction]);\r\n\r\n    /**\r\n     * Release a lock on an object\r\n     */\r\n\r\n    /**\r\n     * Release all locks held by current user\r\n     */\r\n    const releaseAllLocks = useCallback(() => {\r\n        myLocks.forEach(elementId => {\r\n            releaseLock(elementId);\r\n        });\r\n    }, [myLocks, releaseLock]);\r\n\r\n    /**\r\n     * Check if an object is locked\r\n     */\r\n    const isLocked = useCallback((elementId: string): boolean => {\r\n        return !!lockedObjects[elementId];\r\n    }, [lockedObjects]);\r\n\r\n    /**\r\n     * Check if an object is locked by current user\r\n     */\r\n    const isLockedByMe = useCallback((elementId: string): boolean => {\r\n        return myLocks.has(elementId);\r\n    }, [myLocks]);\r\n\r\n    /**\r\n     * Get lock information for an object\r\n     */\r\n    const getLockInfo = useCallback((elementId: string): LockInfo | null => {\r\n        return lockedObjects[elementId] || null;\r\n    }, [lockedObjects]);\r\n\r\n    /**\r\n     * Set up socket listeners for lock events\r\n     */\r\n    useEffect(() => {\r\n        if (!socket) return;\r\n\r\n        // Handle lock granted\r\n        const handleLockGranted = ({ elementId, userId: lockUserId, username: lockUsername, color }: any) => {\r\n            setLockedObjects(prev => ({\r\n                ...prev,\r\n                [elementId]: {\r\n                    userId: lockUserId,\r\n                    username: lockUsername,\r\n                    color,\r\n                    timestamp: Date.now(),\r\n                    elementId\r\n                }\r\n            }));\r\n\r\n            // If this is our lock, add to myLocks and set timeout\r\n            if (lockUserId === userId) {\r\n                setMyLocks(prev => {\r\n                    const next = new Set(prev);\r\n                    next.add(elementId);\r\n                    return next;\r\n                });\r\n                setLockTimeout(elementId);\r\n            }\r\n        };\r\n\r\n        // Handle lock released\r\n        const handleLockReleased = ({ elementId, userId: releaseUserId, isAutoRelease }: any) => {\r\n            setLockedObjects(prev => {\r\n                const next = { ...prev };\r\n                delete next[elementId];\r\n                return next;\r\n            });\r\n\r\n            // If this was our lock, remove from myLocks and clear timeout\r\n            if (releaseUserId === userId) {\r\n                setMyLocks(prev => {\r\n                    const next = new Set(prev);\r\n                    next.delete(elementId);\r\n                    return next;\r\n                });\r\n                clearLockTimeout(elementId);\r\n            }\r\n        };\r\n\r\n        // Handle lock denied\r\n        const handleLockDenied = ({ elementId, reason }: any) => {\r\n            console.warn(`Lock denied for ${elementId}: ${reason}`);\r\n            // Could show a toast notification here\r\n        };\r\n\r\n        // Handle force unlock (by moderator or timeout)\r\n        const handleForceUnlock = ({ elementId, reason }: any) => {\r\n            setLockedObjects(prev => {\r\n                const next = { ...prev };\r\n                delete next[elementId];\r\n                return next;\r\n            });\r\n\r\n            // If this was our lock, remove from myLocks\r\n            if (myLocks.has(elementId)) {\r\n                setMyLocks(prev => {\r\n                    const next = new Set(prev);\r\n                    next.delete(elementId);\r\n                    return next;\r\n                });\r\n                clearLockTimeout(elementId);\r\n            }\r\n        };\r\n\r\n        socket.on('lock-granted', handleLockGranted);\r\n        socket.on('lock-released', handleLockReleased);\r\n        socket.on('lock-denied', handleLockDenied);\r\n        socket.on('force-unlock', handleForceUnlock);\r\n\r\n        return () => {\r\n            socket.off('lock-granted', handleLockGranted);\r\n            socket.off('lock-released', handleLockReleased);\r\n            socket.off('lock-denied', handleLockDenied);\r\n            socket.off('force-unlock', handleForceUnlock);\r\n\r\n            // Release all locks on unmount\r\n            releaseAllLocks();\r\n\r\n            // Clear all timeouts\r\n            Object.values(lockTimeoutsRef.current).forEach(clearTimeout);\r\n            lockTimeoutsRef.current = {};\r\n        };\r\n    }, [socket, userId, myLocks, setLockTimeout, clearLockTimeout, releaseAllLocks]);\r\n\r\n    return {\r\n        lockedObjects,\r\n        myLocks,\r\n        requestLock,\r\n        releaseLock,\r\n        releaseAllLocks,\r\n        isLocked,\r\n        isLockedByMe,\r\n        getLockInfo\r\n    };\r\n}","usedDeprecatedRules":[]}]
