
> frontend@0.0.0 lint
> eslint . --quiet --format json

[{"filePath":"C:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useLayers.ts","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useLayers.ts:67:7\n  65 |   useEffect(() => {\n  66 |     if (layerState.layers.length === 0) {\n> 67 |       createLayer('Background', true);\n     |       ^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  68 |     }\n  69 |   }, [createLayer, layerState.layers.length]);\n  70 |","line":67,"column":7,"nodeType":null,"endLine":67,"endColumn":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect } from 'react';\r\nimport type { Layer, LayerPanelState, DrawingElement } from '../types/canvas';\r\n\r\n/**\r\n * Default layer colors for visual distinction\r\n */\r\nconst LAYER_COLORS = [\r\n  '#3b82f6', // blue\r\n  '#ef4444', // red\r\n  '#10b981', // green\r\n  '#f59e0b', // amber\r\n  '#8b5cf6', // purple\r\n  '#ec4899', // pink\r\n  '#06b6d4', // cyan\r\n  '#84cc16', // lime\r\n  '#f97316', // orange\r\n  '#6366f1', // indigo\r\n];\r\n\r\n/**\r\n * Custom hook for managing layers\r\n * \r\n * @param elements - Array of drawing elements\r\n * @param setElements - Function to update elements\r\n */\r\nexport function useLayers(\r\n  elements: DrawingElement[],\r\n  setElements: (elements: DrawingElement[] | ((prev: DrawingElement[]) => DrawingElement[])) => void\r\n) {\r\n  const [layerState, setLayerState] = useState<LayerPanelState>({\r\n    layers: [],\r\n    activeLayerId: null,\r\n    isExpanded: true,\r\n    panelWidth: 280\r\n  });\r\n\r\n  /**\r\n   * Create a new layer\r\n   */\r\n  const createLayer = useCallback((name?: string, setActive: boolean = true) => {\r\n    const newLayer: Layer = {\r\n      id: `layer-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,\r\n      name: name || `Layer ${layerState.layers.length + 1}`,\r\n      visible: true,\r\n      locked: false,\r\n      opacity: 1,\r\n      blendMode: 'normal',\r\n      index: layerState.layers.length,\r\n      elementIds: [],\r\n      color: LAYER_COLORS[layerState.layers.length % LAYER_COLORS.length]\r\n    };\r\n\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: [...prev.layers, newLayer],\r\n      activeLayerId: setActive ? newLayer.id : prev.activeLayerId\r\n    }));\r\n\r\n    return newLayer;\r\n  }, [layerState.layers]);\r\n\r\n  /**\r\n   * Initialize default layer if none exist\r\n   */\r\n  useEffect(() => {\r\n    if (layerState.layers.length === 0) {\r\n      createLayer('Background', true);\r\n    }\r\n  }, [createLayer, layerState.layers.length]);\r\n\r\n  /**\r\n   * Ensure all elements have valid layerIds\r\n   */\r\n  useEffect(() => {\r\n    if (layerState.layers.length === 0 || !layerState.activeLayerId) return;\r\n\r\n    // Check if any elements are missing layerId or have invalid layerId\r\n    const needsUpdate = elements.some(el =>\r\n      !el.layerId || !layerState.layers.find(l => l.id === el.layerId)\r\n    );\r\n\r\n    if (needsUpdate) {\r\n      setElements(prev => prev.map(el => ({\r\n        ...el,\r\n        layerId: el.layerId && layerState.layers.find(l => l.id === el.layerId)\r\n          ? el.layerId\r\n          : layerState.activeLayerId!\r\n      })));\r\n    }\r\n  }, [elements, layerState.layers, layerState.activeLayerId, setElements]);\r\n\r\n  /**\r\n   * Update layer element counts\r\n   */\r\n  const updateLayerElementCounts = useCallback(() => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer => ({\r\n        ...layer,\r\n        elementIds: elements\r\n          .filter(el => el.layerId === layer.id)\r\n          .map(el => el.id)\r\n      }))\r\n    }));\r\n  }, [elements]);\r\n\r\n  /**\r\n   * Delete a layer\r\n   */\r\n  const deleteLayer = useCallback((layerId: string) => {\r\n    // Don't delete if it's the last layer\r\n    if (layerState.layers.length <= 1) return;\r\n\r\n    setLayerState(prev => {\r\n      const newLayers = prev.layers.filter(l => l.id !== layerId);\r\n\r\n      // Move elements from deleted layer to next available layer\r\n      const targetLayerId = newLayers[0]?.id;\r\n\r\n      if (targetLayerId) {\r\n        setElements(prevElements =>\r\n          prevElements.map(el =>\r\n            el.layerId === layerId ? { ...el, layerId: targetLayerId } : el\r\n          )\r\n        );\r\n      }\r\n\r\n      // Update indices\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers,\r\n        activeLayerId: prev.activeLayerId === layerId ? newLayers[0]?.id : prev.activeLayerId\r\n      };\r\n    });\r\n  }, [layerState.layers, setElements]);\r\n\r\n  /**\r\n   * Duplicate a layer\r\n   */\r\n  const duplicateLayer = useCallback((layerId: string) => {\r\n    const sourceLayer = layerState.layers.find(l => l.id === layerId);\r\n    if (!sourceLayer) return;\r\n\r\n    // Create new layer\r\n    const newLayer: Layer = {\r\n      ...sourceLayer,\r\n      id: `layer-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,\r\n      name: `${sourceLayer.name} (copy)`,\r\n      index: sourceLayer.index + 1,\r\n      elementIds: []\r\n    };\r\n\r\n    // Duplicate elements from source layer\r\n    const elementsToDuplicate = elements.filter(el => el.layerId === layerId);\r\n    const newElements = elementsToDuplicate.map(el => ({\r\n      ...el,\r\n      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n      layerId: newLayer.id,\r\n      x: (el.x || 0) + 20, // Offset by 20px\r\n      y: (el.y || 0) + 20\r\n    }));\r\n\r\n    // Add new elements\r\n    setElements(prev => [...prev, ...newElements]);\r\n\r\n    // Update layers\r\n    setLayerState(prev => {\r\n      const newLayers = [...prev.layers];\r\n      newLayers.splice(sourceLayer.index + 1, 0, newLayer);\r\n\r\n      // Update indices of subsequent layers\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers,\r\n        activeLayerId: newLayer.id\r\n      };\r\n    });\r\n  }, [layerState.layers, elements, setElements]);\r\n\r\n  /**\r\n   * Toggle layer visibility\r\n   */\r\n  const toggleLayerVisibility = useCallback((layerId: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, visible: !layer.visible }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Toggle layer lock\r\n   */\r\n  const toggleLayerLock = useCallback((layerId: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, locked: !layer.locked }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Set active layer\r\n   */\r\n  const setActiveLayer = useCallback((layerId: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      activeLayerId: layerId\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Rename layer\r\n   */\r\n  const renameLayer = useCallback((layerId: string, newName: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, name: newName }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Change layer opacity\r\n   */\r\n  const setLayerOpacity = useCallback((layerId: string, opacity: number) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, opacity }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Change layer blend mode\r\n   */\r\n  const setLayerBlendMode = useCallback((layerId: string, blendMode: Layer['blendMode']) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, blendMode }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Reorder layers (drag and drop)\r\n   */\r\n  const reorderLayers = useCallback((sourceIndex: number, targetIndex: number) => {\r\n    if (sourceIndex === targetIndex) return;\r\n\r\n    setLayerState(prev => {\r\n      const newLayers = [...prev.layers];\r\n      const [movedLayer] = newLayers.splice(sourceIndex, 1);\r\n      newLayers.splice(targetIndex, 0, movedLayer);\r\n\r\n      // Update indices\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers\r\n      };\r\n    });\r\n  }, []);\r\n\r\n  /**\r\n   * Merge layer down\r\n   */\r\n  const mergeLayerDown = useCallback((layerId: string) => {\r\n    const layerIndex = layerState.layers.findIndex(l => l.id === layerId);\r\n    if (layerIndex <= 0) return; // Can't merge the bottom layer\r\n\r\n    const targetLayer = layerState.layers[layerIndex];\r\n    const bottomLayer = layerState.layers[layerIndex - 1];\r\n\r\n    // Move all elements from target layer to bottom layer\r\n    setElements(prev =>\r\n      prev.map(el =>\r\n        el.layerId === targetLayer.id\r\n          ? { ...el, layerId: bottomLayer.id }\r\n          : el\r\n      )\r\n    );\r\n\r\n    // Remove target layer\r\n    setLayerState(prev => {\r\n      const newLayers = prev.layers.filter((_, idx) => idx !== layerIndex);\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers,\r\n        activeLayerId: bottomLayer.id\r\n      };\r\n    });\r\n  }, [layerState.layers, setElements]);\r\n\r\n  /**\r\n   * Get elements for a specific layer (considering visibility)\r\n   */\r\n  const getLayerElements = useCallback((layerId: string): DrawingElement[] => {\r\n    const layer = layerState.layers.find(l => l.id === layerId);\r\n    if (!layer || !layer.visible) return [];\r\n\r\n    return elements.filter(el => el.layerId === layerId);\r\n  }, [elements, layerState.layers]);\r\n\r\n  /**\r\n   * Check if a layer is editable (visible and not locked)\r\n   */\r\n  const isLayerEditable = useCallback((layerId: string): boolean => {\r\n    const layer = layerState.layers.find(l => l.id === layerId);\r\n    return layer ? layer.visible && !layer.locked : false;\r\n  }, [layerState.layers]);\r\n\r\n  return {\r\n    layerState,\r\n    createLayer,\r\n    deleteLayer,\r\n    duplicateLayer,\r\n    toggleLayerVisibility,\r\n    toggleLayerLock,\r\n    setActiveLayer,\r\n    renameLayer,\r\n    setLayerOpacity,\r\n    setLayerBlendMode,\r\n    reorderLayers,\r\n    mergeLayerDown,\r\n    getLayerElements,\r\n    isLayerEditable,\r\n    updateLayerElementCounts,\r\n    setLayerState\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useObjectLocks.ts","messages":[{"ruleId":"react-hooks/immutability","severity":2,"message":"Error: Cannot access variable before it is declared\n\n`releaseLock` is accessed before it is declared, which prevents the earlier access from updating when this value changes over time.\n\nC:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useObjectLocks.ts:70:17\n  68 |             // Auto-release the lock after timeout\n  69 |             if (myLocks.has(elementId)) {\n> 70 |                 releaseLock(elementId, true); // true = auto-release\n     |                 ^^^^^^^^^^^ `releaseLock` accessed before it is declared\n  71 |             }\n  72 |         }, lockTimeout);\n  73 |     }, [lockTimeout, myLocks]);\n\nC:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useObjectLocks.ts:109:5\n  107 |      * Release a lock on an object\n  108 |      */\n> 109 |     const releaseLock = useCallback((elementId: string, isAutoRelease: boolean = false) => {\n      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 110 |         if (!roomId || !userId) return;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 111 |\n      ΓÇª\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 134 |         }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 135 |     }, [socket, roomId, userId, myLocks, clearLockTimeout, isConnected, queueAction]);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `releaseLock` is declared here\n  136 |\n  137 |     /**\n  138 |      * Release all locks held by current user","line":70,"column":17,"nodeType":null,"endLine":70,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect, useRef } from 'react';\r\nimport type { Socket } from 'socket.io-client';\r\n\r\n/**\r\n * Interface for lock information\r\n */\r\nexport interface LockInfo {\r\n    userId: string;\r\n    username: string;\r\n    color: string;\r\n    timestamp: number;\r\n    elementId: string;\r\n}\r\n\r\n/**\r\n * Props for useObjectLocks hook\r\n */\r\ninterface UseObjectLocksProps {\r\n    socket: Socket | null;\r\n    roomId: string | undefined;\r\n    userId: string | undefined;\r\n    username: string | undefined;\r\n    userColor?: string;\r\n    lockTimeout?: number; // milliseconds before auto-release\r\n    isConnected?: boolean; // Add this for offline support\r\n    queueAction?: (type: string, data: any) => string; // Add this for offline queue\r\n}\r\n\r\n/**\r\n * Custom hook for managing object locking in collaborative environments\r\n * \r\n * @param props - Hook properties\r\n * @returns Lock state and functions\r\n */\r\nexport function useObjectLocks({\r\n    socket,\r\n    roomId,\r\n    userId,\r\n    username,\r\n    userColor = '#3b82f6',\r\n    lockTimeout = 30000, // 30 seconds default\r\n    isConnected = true,\r\n    queueAction\r\n}: UseObjectLocksProps) {\r\n    const [lockedObjects, setLockedObjects] = useState<Record<string, LockInfo>>({});\r\n    const [myLocks, setMyLocks] = useState<Set<string>>(new Set());\r\n\r\n    // Refs for timeout management\r\n    const lockTimeoutsRef = useRef<Record<string, NodeJS.Timeout>>({});\r\n\r\n    /**\r\n     * Clear timeout for a specific lock\r\n     */\r\n    const clearLockTimeout = useCallback((elementId: string) => {\r\n        if (lockTimeoutsRef.current[elementId]) {\r\n            clearTimeout(lockTimeoutsRef.current[elementId]);\r\n            delete lockTimeoutsRef.current[elementId];\r\n        }\r\n    }, []);\r\n\r\n    /**\r\n     * Set timeout to auto-release a lock\r\n     */\r\n    const setLockTimeout = useCallback((elementId: string) => {\r\n        clearLockTimeout(elementId);\r\n\r\n        lockTimeoutsRef.current[elementId] = setTimeout(() => {\r\n            // Auto-release the lock after timeout\r\n            if (myLocks.has(elementId)) {\r\n                releaseLock(elementId, true); // true = auto-release\r\n            }\r\n        }, lockTimeout);\r\n    }, [lockTimeout, myLocks]);\r\n\r\n    /**\r\n     * Request a lock on an object\r\n     */\r\n    const requestLock = useCallback((elementId: string) => {\r\n        if (!roomId || !userId) return false;\r\n\r\n        // Don't request if already locked by self\r\n        if (myLocks.has(elementId)) {\r\n            // Renew the timeout\r\n            setLockTimeout(elementId);\r\n            return true;\r\n        }\r\n\r\n        const lockData = {\r\n            roomId,\r\n            elementId,\r\n            userId,\r\n            username,\r\n            color: userColor\r\n        };\r\n\r\n        if (socket && isConnected) {\r\n            socket.emit('request-lock', lockData);\r\n        } else if (queueAction) {\r\n            // Queue for when we're back online\r\n            queueAction('request-lock', lockData);\r\n        }\r\n\r\n        return true;\r\n    }, [socket, roomId, userId, username, userColor, myLocks, setLockTimeout, isConnected, queueAction]);\r\n\r\n    /**\r\n     * Release a lock on an object\r\n     */\r\n    const releaseLock = useCallback((elementId: string, isAutoRelease: boolean = false) => {\r\n        if (!roomId || !userId) return;\r\n\r\n        if (myLocks.has(elementId)) {\r\n            const releaseData = {\r\n                roomId,\r\n                elementId,\r\n                userId,\r\n                isAutoRelease\r\n            };\r\n\r\n            if (socket && isConnected) {\r\n                socket.emit('release-lock', releaseData);\r\n            } else if (queueAction) {\r\n                queueAction('release-lock', releaseData);\r\n            }\r\n\r\n            // Optimistically update local state\r\n            setMyLocks(prev => {\r\n                const next = new Set(prev);\r\n                next.delete(elementId);\r\n                return next;\r\n            });\r\n\r\n            clearLockTimeout(elementId);\r\n        }\r\n    }, [socket, roomId, userId, myLocks, clearLockTimeout, isConnected, queueAction]);\r\n\r\n    /**\r\n     * Release all locks held by current user\r\n     */\r\n    const releaseAllLocks = useCallback(() => {\r\n        myLocks.forEach(elementId => {\r\n            releaseLock(elementId);\r\n        });\r\n    }, [myLocks, releaseLock]);\r\n\r\n    /**\r\n     * Check if an object is locked\r\n     */\r\n    const isLocked = useCallback((elementId: string): boolean => {\r\n        return !!lockedObjects[elementId];\r\n    }, [lockedObjects]);\r\n\r\n    /**\r\n     * Check if an object is locked by current user\r\n     */\r\n    const isLockedByMe = useCallback((elementId: string): boolean => {\r\n        return myLocks.has(elementId);\r\n    }, [myLocks]);\r\n\r\n    /**\r\n     * Get lock information for an object\r\n     */\r\n    const getLockInfo = useCallback((elementId: string): LockInfo | null => {\r\n        return lockedObjects[elementId] || null;\r\n    }, [lockedObjects]);\r\n\r\n    /**\r\n     * Set up socket listeners for lock events\r\n     */\r\n    useEffect(() => {\r\n        if (!socket) return;\r\n\r\n        // Handle lock granted\r\n        const handleLockGranted = ({ elementId, userId: lockUserId, username: lockUsername, color }: any) => {\r\n            setLockedObjects(prev => ({\r\n                ...prev,\r\n                [elementId]: {\r\n                    userId: lockUserId,\r\n                    username: lockUsername,\r\n                    color,\r\n                    timestamp: Date.now(),\r\n                    elementId\r\n                }\r\n            }));\r\n\r\n            // If this is our lock, add to myLocks and set timeout\r\n            if (lockUserId === userId) {\r\n                setMyLocks(prev => {\r\n                    const next = new Set(prev);\r\n                    next.add(elementId);\r\n                    return next;\r\n                });\r\n                setLockTimeout(elementId);\r\n            }\r\n        };\r\n\r\n        // Handle lock released\r\n        const handleLockReleased = ({ elementId, userId: releaseUserId, isAutoRelease }: any) => {\r\n            setLockedObjects(prev => {\r\n                const next = { ...prev };\r\n                delete next[elementId];\r\n                return next;\r\n            });\r\n\r\n            // If this was our lock, remove from myLocks and clear timeout\r\n            if (releaseUserId === userId) {\r\n                setMyLocks(prev => {\r\n                    const next = new Set(prev);\r\n                    next.delete(elementId);\r\n                    return next;\r\n                });\r\n                clearLockTimeout(elementId);\r\n            }\r\n        };\r\n\r\n        // Handle lock denied\r\n        const handleLockDenied = ({ elementId, reason }: any) => {\r\n            console.warn(`Lock denied for ${elementId}: ${reason}`);\r\n            // Could show a toast notification here\r\n        };\r\n\r\n        // Handle force unlock (by moderator or timeout)\r\n        const handleForceUnlock = ({ elementId, reason }: any) => {\r\n            setLockedObjects(prev => {\r\n                const next = { ...prev };\r\n                delete next[elementId];\r\n                return next;\r\n            });\r\n\r\n            // If this was our lock, remove from myLocks\r\n            if (myLocks.has(elementId)) {\r\n                setMyLocks(prev => {\r\n                    const next = new Set(prev);\r\n                    next.delete(elementId);\r\n                    return next;\r\n                });\r\n                clearLockTimeout(elementId);\r\n            }\r\n        };\r\n\r\n        socket.on('lock-granted', handleLockGranted);\r\n        socket.on('lock-released', handleLockReleased);\r\n        socket.on('lock-denied', handleLockDenied);\r\n        socket.on('force-unlock', handleForceUnlock);\r\n\r\n        return () => {\r\n            socket.off('lock-granted', handleLockGranted);\r\n            socket.off('lock-released', handleLockReleased);\r\n            socket.off('lock-denied', handleLockDenied);\r\n            socket.off('force-unlock', handleForceUnlock);\r\n\r\n            // Release all locks on unmount\r\n            releaseAllLocks();\r\n\r\n            // Clear all timeouts\r\n            Object.values(lockTimeoutsRef.current).forEach(clearTimeout);\r\n            lockTimeoutsRef.current = {};\r\n        };\r\n    }, [socket, userId, myLocks, setLockTimeout, clearLockTimeout, releaseAllLocks]);\r\n\r\n    return {\r\n        lockedObjects,\r\n        myLocks,\r\n        requestLock,\r\n        releaseLock,\r\n        releaseAllLocks,\r\n        isLocked,\r\n        isLockedByMe,\r\n        getLockInfo\r\n    };\r\n}","usedDeprecatedRules":[]}]
